<br>

## 3차시

```python
D = [[1, 0], [0, 1]]		# 아래와 오른쪽으로만

def dfs(i, j, sums):
    global ans
    sums += maps[i][j]		# 더해주기
    if sums > ans:			# 가지 치기
        return
    elif i == N-1 and j == N-1:		# 마지막이면 계산
        if sums < ans:
            ans = sums
        return
    else:
        for di, dj in D:
            x, y = i + di, j + dj
            if 0 <= x < N and 0 <= y < N:	# 범위 내에서 재귀
                dfs(x, y, sums)

T = int(input())
for tc in range(1, T+1):
    N = int(input())
    maps = [list(map(int, input().split())) for _ in range(N)]
    ans = sum(sum(maps[i]) for i in range(N))	# 최댓값
    dfs(0, 0, 0)
    print(f'#{tc} {ans}')
```

<br>

<br>

## 4차시

```python
def dfs(k, n, sums):
    global ans, N
    if sums > ans:		# 가지 치기
        return
    elif n == N-1:
        sums += maps[k][0]		# 마지막으로 복귀를 더해줌
        if sums < ans:
            ans = sums
        return
    else:
        for i in range(N):
            if not visit[i]:		# 방문 처리 해주면서 재귀
                visit[i] = 1
                dfs(i, n+1, sums + maps[k][i])
                visit[i] = 0

T = int(input())
for tc in range(1, T+1):
    N = int(input())
    maps = [list(map(int, input().split())) for _ in range(N)]
    ans = sum(sum(maps[i]) for i in range(N))
    visit = [1] + [0] * (N-1)
    dfs(0, 0, 0)
    print(f'#{tc} {ans}')
```

<br>

<br>

## 일곱 난쟁이

```python
nums = sorted([int(input()) for _ in range(9)])		# 미리 정렬
cnt = sum(nums)
ans = []
for i in range(8):		# 전체 합에서 2개씩 빼는걸로
    cnt -= nums[i]
    for j in range(i+1, 9):
        cnt -= nums[j]
        if cnt == 100:		# 찾으면
            for k in range(9):
                if k not in [i, j]:		# 지금 두 개 빼고 나머지 전부 출력
                    print(nums[k])
            quit()
        cnt += nums[j]
    cnt += nums[i]
```

<br>

<br>

## 사탕 게임

```python
D = [[1, 0], [0, 1]]		# 오른쪽과 아래만 한 번 씩 바꿔주면 전부 바꿀 수 있음
N = int(input())
candy = [list(map(str, input())) for _ in range(N)]
max_val = 1		# 최소치는 1
for i in range(N):
    for j in range(N):
        for di, dj in D:			# 각위치에서 주변의 다른 사탕과 자리를 바꿈
            x, y = i + di, j + dj
            if 0 <= x < N and 0 <= y < N and candy[x][y] != candy[i][j]:
                candy[x][y], candy[i][j] = candy[i][j], candy[x][y]
                for a in range(N):		# 바꾼 상태에서 가로, 세로 동시 탐색
                    ca = cb = 1
                    for b in range(1, N):
                        if candy[a][b] == candy[a][b-1]:
                            ca += 1
                        else:
                            if ca > max_val:
                                max_val = ca
                            ca = 1
                        if candy[b][a] == candy[b-1][a]:
                            cb += 1
                        else:
                            if cb > max_val:
                                max_val = cb
                            cb = 1
                    if ca > max_val:
                        max_val = ca
                    if cb > max_val:
                        max_val = cb
                candy[x][y], candy[i][j] = candy[i][j], candy[x][y]
print(max_val)
```

<br>

<br>

## 날짜 계산

```python
nums = list(map(int, input().split()))
for n in range(1, 8513):		# 세 개의 최소공배수는 8512임.
    temp = [(n-1) % 15 + 1, (n-1) % 28 + 1, (n-1) % 19 + 1]		# 같은 값이 나올 때까지 증가
    if temp == nums:
        break
print(n)
```

```python
E, S, M = map(int, input().split())		# 약 2배 정도 빠름
for n in range(S, 8513, 28):		# 찾는 숫자는 28의 배수 + S 이기도 하므로, S를 기준으로 계산
    e, m = (n-1) % 15 + 1, (n-1) % 19 + 1
    if E == e and M == m:
        break
print(n)
```



<br>

<br>

---

*end*