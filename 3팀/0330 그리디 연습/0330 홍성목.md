## 그리디 연습

<br>

<br>

#### 동전 0

```python
# 거스름돈과 같은 유형
# Ai는 Ai-1의 배수이므로 부분집합으로 탐색 할 필요가 없다.

N, K = map(int, input().split())
coin = [int(input()) for _ in range(N)]
cnt = 0
i =-1		# 뒤에서부터 탐색
while K:	# 돈이 남아있을 동안 반복
    if K >= coin[i]:
        cnt += K // coin[i]		# 뺄 수 있는 만큼 빼서 카운트
        K %= coin[i]			# 남은 돈을 다시 K에 저장
    i -= 1
print(cnt)
```

<br>

<br>

#### 회의실 배정

```python
# 제일 먼저 끝나는 순서대로 정렬하여 연결하면 최대 개수를 얻을 수 있다.
# 귀류법 : 제일 먼저 끝나는 순서대로 정렬해도 최대 개수를 얻을 수 없다.
# 하지만 끝나는 시간 순서대로 정렬할 경우, 제일 먼저 끝나는 회의가 그 다음으로 끝나는 회의에 비해, 다음으로 연결할 수 있는 회의가 더 많은 것은 명백하므로 이는 틀렸다.

# 결국 문제의 본질은 '비어있는 24칸에 최대한 많은 회의를 넣는 것'이다.
# 그렇기에 시작이 끝이어도 되고, 끝이 시작이어도 된다.
# 따라서 시작 시간 순으로 정렬하여, 시작시간이 제일 늦은 회의를 찾는다. 이를 반복한다.

N = int(input())
table = sorted([list(map(int, input().split())) for _ in range(N)])
start = table[N-1][0]	# 제일 마지막 값이 시작시간이 제일 늦으므로
cnt = 1		# 이미 마지막 회의는 포함되어 있으므로
for i in range(N-2, -1, -1):	# 뒤에서부터 탐색
    if start >= table[i][1]:	# 만약 해당 종료시간이 저장된 시작시간보다 빠를 경우
        start = table[i][0]		# 시작 시간을 갱신
        cnt += 1
print(cnt)
```

<br>

<br>

#### ATM

```python
# 시간이 중첩되는 문제
# 따라서 제일 큰 수가 제일 중첩이 안 되도록 마지막으로 보내면 된다.
# 역순으로 배열 후 가중치 곱해서 더해주기

N = int(input())
times = sorted(list(map(int, input().split())), reverse=True)
print(sum(times[i] * (i+1) for i in range(N)))
```

<br>

<br>

#### 행렬

```python
# 처음부터 끝까지, 오른쪽 끝 2칸과 아래 끝 2칸을 제외하고 한 칸 씩 전부 탐색한다.
# 만약 두 행렬이 다른 경우, 해당 칸 기준 오른쪽과 아래로 3 x 3 만큼 전부 뒤집는다.
# 이 방법이 타당한 것은 아래와 같이 증명 가능하다.

# 1. 처음부터 순서대로 순회하면서 변경하면 그것이 곧 최소 회수이다. (답을 구할 수 있다는 가정 하)
# 귀류법 : 처음부터 순서대로 변경해주는 방법으로 구한 회수는 최소가 아니다.
# 그런데 답을 구한 상태라면, A와 B 배열은 완벽히 같아진다.
# 따라서 순회하는 방법으로 답을 구했을 때 그 회수가 최소회수가 아니려면 '똑같은 곳을 최소 2회 이상' 뒤집는 경우가 있어야한다.
# 그러나 해당 방법은 모든 칸은 한 번 씩만 방문하므로, 똑같은 곳이 2번 이상 뒤집히는 경우는 없다.
# 따라서 처음부터 순회하면서 뒤집을 경우 그 회수가 곧 최소 회수이다.

# 2. 처음부터 순서대로 변경해주면 답을 찾을 수 있다. (답을 구할 수 있는가 없는가를 가정)
# 귀류법 : 처음부터 순서대로 확인하며 뒤집는 방법으로는 답을 찾을 수 없다.
# 즉, 처음 탐색 때는 0이었으나 탐색 이후 1이 되는 경우가 존재한다.
# 하지만 뒤집힐 수 있는 블록은 항상 우하단에 위치하고, 탐색이 끝난 블록들은 좌상단으로 밀리게 된다.
# 따라서 탐색이 끝난 블록은 반대편에 위치하게 되므로 값이 다시 1로 바뀔 수 없다.
# 그러므로 처음부터 순서대로 순회하며 뒤집는 경우, 탐색이 끝난 칸이 다시 1로 바뀔 수 없고
# 즉 모든 경우를 탐색하며 뒤집을 수 있으므로 해당 방법은 옳다


N, M = map(int, input().split())
A = [input() for _ in range(N)]
B = [input() for _ in range(N)]
ans = 0
check = [[0] * M for _ in range(N)]		# 뒤집을 배열을 따로 만들기
for i in range(N):
    for j in range(M):
        if A[i][j] != B[i][j]:
            check[i][j] = 1			# 값이 서로 다르면 1
if N < 3 or M < 3:		# 크기가 작은 경우, 뒤집을 수 없으므로 둘이 같으면 0, 다르면 -1이 된다.
    print(-1 if sum(sum(check[i]) for i in range(N)) else ans)
else:
    for i in range(N-2):
        for j in range(M-2):
            if check[i][j]:		# 1이 나오면 3 x 3 만큼 뒤집어준다
                ans += 1
                for x in range(3):
                    for y in range(3):
                        check[i+x][j+y] = 0 if check[i+x][j+y] else 1
    # check의 합계가 0이면 답이 있는 것이고, 0이 아니면 답이 없으므로
    print(-1 if sum(sum(check[i]) for i in range(N)) else ans)
```

<br>

<br>

---

*end*