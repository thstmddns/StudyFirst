## 그래프 탐색 응용

<br>

<br>

#### 나이트의 이동

```python
import sys
input = sys.stdin.readline
from collections import deque

def bfs(si,sj):
    dq = deque()
    dq.append((si,sj))
    
    while dq:
        ci,cj = dq.popleft()
        if ci==gi and cj==gj:
            return arr[gi][gj]
        for k in range(8):
            ni,nj = ci+di[k], cj+dj[k]
            if 0<=ni<N and 0<=nj<N and arr[ni][nj]==0:
                dq.append((ni,nj))
                arr[ni][nj] = arr[ci][cj]+1

di,dj = [-2,-2,-1,-1,1,1,2,2],[-1,1,-2,2,-2,2,-1,1]
for T in range(int(input())):
    N = int(input())
    arr = [[0]*N for _ in range(N)]
    i, j = map(int, input().split())  # 현재 칸
    gi, gj = map(int, input().split())  # 목표 칸
    print(bfs(i,j))
```

<br>

<br>

#### Two Dots

```python
# 푸는 중...
import sys
input = sys.stdin.readline
from collections import deque

def dfs(si,sj,aa,ei,ej,cnt):
    global ans
    if ans:
        return
    for k in range(4):
        ni,nj = si+di[k],sj+dj[k]
        if cnt>=4 and ni==ei and nj==ej:
            ans = 1
            return
        if 0<=ni<N and 0<=nj<M and arr[ni][nj]==aa and v[ni][nj]==0:
            v[ni][nj]=1
            dfs(ni,nj,aa,ei,ej,cnt+1)
            v[ni][nj]=0

def check():
    for i in range(N):
        for j in range(M):
            a = arr[i][j]
            v[i][j]=1
            dfs(i,j,a,i,j,0)
            if ans:
                return 'Yes'
    return 'No'

# 상:0, 하:1, 좌:2, 우:3
di,dj = [-1,1,0,0],[0,0,-1,1]
N, M = map(int, input().split())
arr = [list(input().rstrip()) for _ in range(N)]
v = [[0]*M for _ in range(N)]
ans = 0
print(check())
```

<br>

<br>

---

*end*