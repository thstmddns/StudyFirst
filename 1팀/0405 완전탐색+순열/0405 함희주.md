## 완전탐색 + 순열 3

<br>

<br>

#### ⚾ (pypy 권장)

```python

```

<br>

<br>

#### 색종이 붙이기

오답

```python
def detach(cx, cy, l):
    global MAP
    for x in range(cx, cx + l):
        for y in range(cy, cy + l):
            MAP[x][y] = 1


def attach(cx, cy, l):
    global MAP
    for x in range(cx, cx + l):
        for y in range(cy, cy + l):
            MAP[x][y] = 0


def get_max_length(cx, cy):
    global N, MAP
    length = 1
    for l in range(2, min(N - cx, N - cy, 5) + 1):
        for x in range(cx, cx + l):
            for y in range(cy, cy + l):
                if 0 == MAP[x][y]:
                    return length
        length += 1
    return length


def dfs(cx, cy, cnt, area):
    global N, MAP, papers, ans, ttl
    if ttl == area:  # 색종이로 전부 덮은 경우
        ans = min(ans, cnt)
        return
    if ans <= cnt or 0 == sum(papers):  # 가지치기
        print('가지치기')
        return
    for n in range(cx * N + cy, N * N):
        nx, ny = n // N, n % N
        if 0 == MAP[nx][ny]:
            continue
        length = get_max_length(nx, ny)
        for l in range(1, length + 1):
            if papers[l] > 0:
                papers[l] -= 1
                attach(nx, ny, l)
                dfs(nx, ny, cnt + 1, area + l * l)
                detach(nx, ny, l)
                papers[l] += 1


N = 10
MAP = [list(map(int, input().split())) for _ in range(N)]
ans = 26
papers = [0, 5, 5, 5, 5, 5]
ttl = sum(_.count(1) for _ in MAP)
dfs(0, 0, 0, 0)
if 26 == ans:
    print(-1)
else:
    print(ans)
```

<br>

---

*end*